

require 'loadcaffe';
require 'cunn'
require 'cudnn'
require 'nn';
require 'image';
npy4th=require 'npy4th'


function makeXavierGaussian(model)
    for idx=1,#model do
        
        local m = model.modules[idx]
        if m.weight then
            local var=nil;
            if m.__typename == 'nn.SpatialConvolution' then
                var = {m.nInputPlane*m.kH*m.kW, m.nOutputPlane*m.kH*m.kW}
            elseif m.__typename == 'nn.SpatialConvolutionMM' then
                var = {m.nInputPlane*m.kH*m.kW, m.nOutputPlane*m.kH*m.kW}
            elseif m.__typename == 'nn.LateralConvolution' then
                var = {m.nInputPlane*1*1, m.nOutputPlane*1*1}
            elseif m.__typename == 'nn.VerticalConvolution' then
                var = {1*m.kH*m.kW, 1*m.kH*m.kW}
            elseif m.__typename == 'nn.HorizontalConvolution' then
                var = {1*m.kH*m.kW, 1*m.kH*m.kW}
            elseif m.__typename == 'nn.Linear' then
                var = {m.weight:size(2), m.weight:size(1)}
            elseif m.__typename == 'nn.TemporalConvolution' then
                var = {m.weight:size(2), m.weight:size(1)}
            end
            if var then
	            var = 2/(var[1] + var[2])
	            m.weight=torch.randn(m.weight:size()):mul(torch.sqrt(var));
	            -- m.weight=m.weight/1000;
	            m.bias=torch.zeros(m.bias:size());
	            
	            -- m.weight=torch.zeros(m.weight:size());
	            -- m.bias=torch.zeros(m.bias:size());
	            
	            print (m.weight:size(),var,torch.var(m.weight));
	        end
        end
    end

    return model
end


function reSaveTPSModel()
    local path_caffe_alexnet='../models/bvlc_alexnet.caffemodel';
    local path_deploy='../models/deploy.prototxt';
    local path_out='../models/tps_untrained_bn_fix.dat';
    local model = loadcaffe.load(path_deploy,path_caffe_alexnet, 'cudnn')

    print (model);

    -- model=model:cuda();
    local new_model=nn.Sequential();
    for layer_num=#model,14,-1 do
         local layer_curr=model:get(layer_num);
         new_model:insert(layer_curr,1);
         model:remove(layer_num);
    end
    print (model);
    new_model:insert(nn.SpatialConvolution(256,128,1,1),1);
    new_model:insert(cudnn.ReLU(),1);
    new_model:insert(nn.SpatialBatchNormalization(256),1);
    
    for layer_num=#new_model,7,-1 do
        new_model:remove(layer_num);
    end
    new_model:add(nn.BatchNormalization(4608));
    new_model:add(nn.Linear(4608,128));
    new_model:add(nn.BatchNormalization(128,25));
    new_model:add(nn.ReLU());
    new_model:add(nn.Dropout(0.5));
    new_model:add(nn.Linear(128,50));
    print (new_model);

    new_model=makeXavierGaussian(new_model);
    -- print (new_model);
    for layer_num =1,#new_model do
        local layer_curr=new_model:get(layer_num);
        model:add(layer_curr);
    end

    model:get(#model).weight:fill(0)
    local layer_last=model:get(#model);
    print (layer_last.weight:size(),torch.min(layer_last.weight),torch.max(layer_last.weight))
    print (layer_last.bias:size(),torch.min(layer_last.bias),torch.max(layer_last.bias))

    model=cudnn.convert(model,cudnn);
    -- print (model);
    model=model:cuda();
    input=torch.Tensor(10,3,227,227);
    local output=model:forward(input:cuda());
    -- print (output:size());

    -- new_model:remove(#new_model);
    -- new_model:remove(#new_model);
    -- new_model:add(nn.Linear(4096,10));
    -- print (new_model);

    -- new_model=makeXavierGaussian(new_model);
    -- for layer_num=1,#new_model do
    --  model:add(new_model:get(layer_num));
    -- end

    -- print (model);


    torch.save(path_out,model);

end



function saveKPNetForImagenetTraining()
    local path_to_tps='../models/human_face_model.dat';
    local path_out='../models/kp_net_untrained_imagenet_nn.dat';
    local model=torch.load(path_to_tps);
    print (model);
    model:remove(#model);
    model:add(nn.Linear(100,1000));
    model:add(nn.SoftMax());
    model=cudnn.convert(model,nn);
    print (model);
    print (torch.min(model:get(26).weight),torch.max(model:get(26).weight));
    model=makeXavierGaussian(model);
    -- model=cudnn.convert(model,cudnn);
    print (torch.min(model:get(26).weight),torch.max(model:get(26).weight));
    local input=torch.Tensor(10,3,227,227):cuda();
    local model=model:cuda();
    -- print (input:size());
    -- local output=model:forward(input);
    -- print ('output',output:size());
    model:clearState();
    print (model)
    -- model:zeroGradParameters();
    torch.save(path_out,model);
    print (path_out)
    -- model:in
end


function saveSoumithModelForLocnet(model_file)
    local model=torch.load(model_file);
    -- print (model);
    local model_second_part=model:get(2);
    model=model:get(1);
    
    for i=1,#model_second_part do
        model:add(model_second_part:get(i));
    end
    -- print (model);
    model:remove(#model);
    model:remove(#model);
    local model_new=nn.Sequential();
    model_new:add(nn.Linear(100,50));
    model_new=makeXavierGaussian(model_new);
    model:add(model_new:get(1));
    -- print (model);
    -- model=model:cuda();
    -- local input=torch.zeros(10,3,224,224):cuda();
    -- local output=model:forward(input);
    -- print (output:size());
    local out_file=paths.concat(paths.dirname(model_file),paths.basename(model_file,'.t7')..'_locnet.dat');
    print (out_file);
    model:clearState();
    torch.save(out_file,model);



end



function main()
    local model_file='../models/imagenet_soumith/model_37.t7';
    saveSoumithModelForLocnet(model_file);

end

main();

-- saveKPNetForImagenetTraining();

