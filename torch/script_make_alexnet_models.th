
require 'stn';
require 'loadcaffe';
require 'cunn'
require 'cudnn'
require 'nn';
require 'image';
npy4th=require 'npy4th'


function makeXavierGaussian(model)
    for idx=1,#model do
        
        local m = model.modules[idx]
        if m.weight then
            local var=nil;
            if m.__typename == 'nn.SpatialConvolution' or m.__typename == 'cudnn.SpatialConvolution' then
                var = {m.nInputPlane*m.kH*m.kW, m.nOutputPlane*m.kH*m.kW}
            elseif m.__typename == 'nn.SpatialConvolutionMM' then
                var = {m.nInputPlane*m.kH*m.kW, m.nOutputPlane*m.kH*m.kW}
            elseif m.__typename == 'nn.LateralConvolution' then
                var = {m.nInputPlane*1*1, m.nOutputPlane*1*1}
            elseif m.__typename == 'nn.VerticalConvolution' then
                var = {1*m.kH*m.kW, 1*m.kH*m.kW}
            elseif m.__typename == 'nn.HorizontalConvolution' then
                var = {1*m.kH*m.kW, 1*m.kH*m.kW}
            elseif m.__typename == 'nn.Linear' then
                var = {m.weight:size(2), m.weight:size(1)}
            elseif m.__typename == 'nn.TemporalConvolution' then
                var = {m.weight:size(2), m.weight:size(1)}
            end
            if var then
	            var = 2/(var[1] + var[2])
	            m.weight=torch.randn(m.weight:size()):mul(torch.sqrt(var));
	            -- m.weight=m.weight/1000;
	            m.bias=torch.zeros(m.bias:size());
	            
	            -- m.weight=torch.zeros(m.weight:size());
	            -- m.bias=torch.zeros(m.bias:size());
	            
	            print (m.weight:size(),var,torch.var(m.weight));
	        end
        end
    end

    return model
end


function reSaveTPSModel()
    local path_caffe_alexnet='../models/bvlc_alexnet.caffemodel';
    local path_deploy='../models/deploy.prototxt';
    local path_out='../models/tps_untrained_bn_fix.dat';
    local model = loadcaffe.load(path_deploy,path_caffe_alexnet, 'cudnn')

    print (model);

    -- model=model:cuda();
    local new_model=nn.Sequential();
    for layer_num=#model,14,-1 do
         local layer_curr=model:get(layer_num);
         new_model:insert(layer_curr,1);
         model:remove(layer_num);
    end
    print (model);
    new_model:insert(nn.SpatialConvolution(256,128,1,1),1);
    new_model:insert(cudnn.ReLU(),1);
    new_model:insert(nn.SpatialBatchNormalization(256),1);
    
    for layer_num=#new_model,7,-1 do
        new_model:remove(layer_num);
    end
    new_model:add(nn.BatchNormalization(4608));
    new_model:add(nn.Linear(4608,128));
    new_model:add(nn.BatchNormalization(128,25));
    new_model:add(nn.ReLU());
    new_model:add(nn.Dropout(0.5));
    new_model:add(nn.Linear(128,50));
    print (new_model);

    new_model=makeXavierGaussian(new_model);
    -- print (new_model);
    for layer_num =1,#new_model do
        local layer_curr=new_model:get(layer_num);
        model:add(layer_curr);
    end

    model:get(#model).weight:fill(0)
    local layer_last=model:get(#model);
    print (layer_last.weight:size(),torch.min(layer_last.weight),torch.max(layer_last.weight))
    print (layer_last.bias:size(),torch.min(layer_last.bias),torch.max(layer_last.bias))

    model=cudnn.convert(model,cudnn);
    -- print (model);
    model=model:cuda();
    input=torch.Tensor(10,3,227,227);
    local output=model:forward(input:cuda());
    -- print (output:size());

    -- new_model:remove(#new_model);
    -- new_model:remove(#new_model);
    -- new_model:add(nn.Linear(4096,10));
    -- print (new_model);

    -- new_model=makeXavierGaussian(new_model);
    -- for layer_num=1,#new_model do
    --  model:add(new_model:get(layer_num));
    -- end

    -- print (model);


    torch.save(path_out,model);

end



function saveKPNetForImagenetTraining()
    local path_to_tps='../models/human_face_model.dat';
    local path_out='../models/kp_net_untrained_imagenet_nn.dat';
    local model=torch.load(path_to_tps);
    print (model);
    model:remove(#model);
    model:add(nn.Linear(100,1000));
    model:add(nn.SoftMax());
    model=cudnn.convert(model,nn);
    print (model);
    print (torch.min(model:get(26).weight),torch.max(model:get(26).weight));
    model=makeXavierGaussian(model);
    -- model=cudnn.convert(model,cudnn);
    print (torch.min(model:get(26).weight),torch.max(model:get(26).weight));
    local input=torch.Tensor(10,3,227,227):cuda();
    local model=model:cuda();
    -- print (input:size());
    -- local output=model:forward(input);
    -- print ('output',output:size());
    model:clearState();
    print (model)
    -- model:zeroGradParameters();
    torch.save(path_out,model);
    print (path_out)
    -- model:in
end


function saveSoumithModelForLocnet(model_file,pivot,out_file)
    local model=torch.load(model_file);
    -- print (model);
    local model_second_part=model:get(2);
    model=model:get(1);
    
    for i=1,#model_second_part do
        model:add(model_second_part:get(i));
    end
    -- print (model);
    -- model=cudnn.convert(model,nn);
    print (model);
    model:remove(#model);
    model:remove(#model);

    if pivot then
        local model_new=nn.Sequential();
        for i=#model,pivot,-1 do
            print (model:get(i));
            if model:get(i).weight then
                print (torch.min(model:get(i).weight),torch.max(model:get(i).weight));
            end
            model:get(i):reset();
            if model:get(i).weight then
                print (torch.min(model:get(i).weight),torch.max(model:get(i).weight));
            end
            model_new:insert(model:get(i),1);
            -- print (model:get(i))
            -- print (model:get(i).reset)
            model:remove(i);
        end
        model_new=makeXavierGaussian(model_new); 
        print (model)
        print (model_new)
        for i=1,#model_new do
            model:add(model_new:get(i));
        end
    end

    -- local√∑ model_new=nn.Sequential();
    model:add(nn.Linear(100,50));
    print (model:get(#model))
    model:get(#model).weight:fill(0);
    model:get(#model).bias:fill(0);
    -- model_new=makeXavierGaussian(model_new);
    -- model:add(model_new:get(1));
    print (model);
    model=model:cuda();
    local input=torch.zeros(10,3,224,224):cuda();
    local output=model:forward(input);
    print (output:size());
    print (torch.min(model:get(#model).weight),torch.max(model:get(#model).weight))
    print (torch.min(model:get(#model).bias),torch.max(model:get(#model).bias));
    
    -- local out_file
    if not out_file then
        out_file=paths.concat(paths.dirname(model_file),paths.basename(model_file,'.t7')..'_locnet.dat');
    end
    print (out_file);
    model:clearState();
    torch.save(out_file,model);



end


function saveWarpNetBnFix(model_file,out_file,affine_flag)
    local model=torch.load(model_file);
    print (model);
    local layer=model:get(15);
    model:remove(15);
    model:insert(layer,14);
    model:remove(20);
    model:insert(nn.SpatialBatchNormalization(128),17);
    local layer=model:get(24);
    model:remove(24);
    model:insert(layer,22);
    print (model);
    local input=torch.Tensor(10,3,224,224):cuda();
    model=model:cuda();
    local output=model:forward(input);
    print (output:size());
    model=model:double();
    model:clearState();
    torch.save(out_file,model);

end

function modifySheepModel(org_model,out_file,num_keypoints,justAdd)
    local net=torch.load(org_model);
    local num_in;
    if not justAdd then
        num_in=100;
    else
        num_in=10;
    end
    if not justAdd then
        local last_layer=net:get(2):get(30);
        net:get(2):remove();
    end
    local net_dummy=nn.Sequential();
    net_dummy:add(nn.Linear(num_in,num_keypoints*2));
    net_dummy=makeXavierGaussian(net_dummy);
    print (net_dummy);
    net:get(2):add(net_dummy:get(1));
    print (net)
    print (out_file)
    torch.save(out_file,net);
end


function main()
    local org_model='../experiments/all_sheep_models/sheep/full_model/final/model_all_final.dat';
    local out_file='../models/pretrained_sheep_full_add_8.dat';
    local num_keypoints=8;
    modifySheepModel(org_model,out_file,num_keypoints,true)

    -- local org_model='../experiments/all_sheep_models/sheep/full_model/final/model_all_final.dat';
    -- local out_file='../models/pretrained_sheep_full_8.dat';
    -- local num_keypoints=8;
    -- modifySheepModel(org_model,out_file,num_keypoints)


    -- local model_file='../models/tps_localization_net_untrained.dat';
    -- local out_file='../models/tps_localization_net_untrained_bn_fix.dat'
    -- local model_file='../models/affine_localization_net_untrained.dat';
    -- local out_file='../models/affine_localization_net_untrained_bn_fix.dat'
    -- saveWarpNetBnFix(model_file,out_file);
    
    -- local model_file='../models/tps_localization_net_untrained_bn_fix.dat';
    -- local out_file='../models/tps_localization_net_untrained_bn_fix_withTPS.dat';
    -- local model=torch.load(model_file);
    -- local tps=nn.TPSGridGeneratorBHWD(25,224,224);
    -- model:add(tps);
    -- print (model)
    -- model:clearState();
    -- torch.save(out_file,model);    


    -- local model_file='../models/imagenet_soumith/model_55.t7';
    -- local out_file='../models/imagenet_soumith/model_55_fc_conv_scratch_locnet.dat';
    -- local out_file=paths.concat(paths.dirname(model_file),paths.basename(model_file,'.t7')..'_locnet.dat');
    -- local out_file='../models/tps_localization_net_untrained.dat';
    -- saveSoumithModelForLocnet(model_file,20,out_file);
    -- local model=torch.load(out_file);
    -- print (torch.min(model:get(#model).weight),torch.max(model:get(#model).weight))
    -- print (torch.min(model:get(#model).bias),torch.max(model:get(#model).bias));
    -- local model=torch.load('/home/maheenrashid/code/animal_human_kp/models/imagenet_soumith/model_37_locnet.dat');
    -- print (model);

end

main();

-- saveKPNetForImagenetTraining();

